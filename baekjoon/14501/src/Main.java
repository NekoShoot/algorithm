
public class Main {

	public static void main(String[] args) {
		// 퇴사 문제
		/* 알고리즘 아이디어
		 * 오늘(0) + N+1 = 퇴사 날
		 * 1 <= N <= 15
		 * 상담에 걸리는 일 수 안에 퇴사 날이 있으면 그 상담은 불가능
		 * -> if i(날짜) + Ti - 1(일수) >= N+1이면, Pi(수익) = 0으로 하기?
		 * 상담에 걸리는 일 수 안에 있는 다른 상담은 불가능
		 * if i 고르면 -> i + Ti가 될 때까지 continue?
		 * 
		 * < 핵심 >
		 * 최대 수익 구하기
		 * how to ?
		 * 방식) 
		 * - 아이디어 1
		 * i_x = (i_(x-1) + Ti_(x-1))를 해나가며 (i_x + Ti_x) < (N+1) 일 때까지 시행하는 모든 경우의 수를 체크
		 * 시행하는 한 세트(x값이 1개 돌아가는 세트)마다 tmp에 값을 저장하고, 맨 마지막에 tmp와 sum의 값을 비교해서 큰 쪽을 sum에 저장
		 * 최종적으로 sum에 저장된 값을 출력
		 * 
		 * - 아이디어 2
		 * 1. i = N(마지막 날)을 탐색. 
		 * 2-1. if N + TN > N+1 이면 그 상담은 불가능하므로 continue로 다음 반복 실행
		 * 2-2. if N + TN <= N+1 이면 그 상담은 가능. N을 cnt(반복문 밖)에, PN을 tmp에 저장한다.
		 * if N - 1 == 1이면 마지막 탐색. (if문을 N번 돌릴 것이라 케어될 듯)
		 * 3. i = N-1을 탐색. (이동)
		 * 4-1. if N-1 + T(N-1) > N이면 N-1날 상담은 불가능하므로 continue로 다음 재귀 실행
		 * 4-2. if N-1 + T(N-1) <= N이면 상담 가능. P(N-1)을 tmp에 더한다. 
		 * 이후 재귀로 가능한 가장 적은 i가 될 때까지 탐색
		 * 5. sum과 tmp를 비교하고 더 큰 쪽을 sum에 저장.
		 * ----------------------------------------------------------------------
		 * 6. 다음 반복에서 i = N-1부터 탐색 시작.
		 * 7-1. if N-1 >= cnt면 중복된 탐색이므로 continue로 다음 반복 실행
		 * 7-2. if N-1 < cnt면 이전 반복에서 하지 않은 탐색이므로 재귀 실행
		 * 
		 * ==> 생각해보니 오히려 첫날부터 시작하는 걸 이 과정으로 탐색하면 될 거 같은 느낌???? 
		 * ==> 재귀가 너무 헷갈린다!!
		 * 
		 * 첫 시행을 제외하고 결국엔
		 * n번째로 점프했을 때의 Pn과, P(n+1) + P((n+1)+T(n+1)) 
		 * 
		 */

	}

}
